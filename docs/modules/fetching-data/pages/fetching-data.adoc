= Fetching Data
keywords: stream, jpastreamer, java, SQL
author: Julia Gustafsson
:reftext: Fetching Data
:navtitle: Fetching Data
:source-highlighter: highlight.js

To start fetching data with JPAstreamer you need to initialize an instance of `JPAStreamer`. This section describes how that is accomplished.

== Obtaining a JPAstreamer instance
JPAstreamer is initialized with the name of the persistence unit like so:

[source, java]
----
JPAStreamer jpaStreamer = JPAStreamer.of("sakila"); #<1>
----
<1> "sakila" is to be replaced with the name of *your* persistence unit that can be found in a configuration-file

In the example, the String "sakila" should refer to the name of your persistance unit. Assuming you are already using a JPA provider, your project should contain an XML-file like the one below, describing the persistence unit:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2"
             xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
     http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">

    <persistence-unit name="sakila" transaction-type="RESOURCE_LOCAL"> #<1>
        <description>MySQL Sakila Example Database</description>
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        <properties>
            <!-- Configuring The Database Connection Details -->
            <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver" />
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/sakila" />

            <!-- ... -->

        </properties>
    </persistence-unit>
</persistence>
----
<1> The name of the persistence unit, in this case "sakila", is used to initialize JPAstreamer.

IMPORTANT: This configuration is just an example configuration for the https://dev.mysql.com/doc/sakila/en/[MySQL Sakila example database]. You should use the configuration you already have in place.

TIP: If you have multiple persistence units, you can initiate several instances of `JPAStreamer` to establish connections with different sources.

JPAstreamer does not need any additional configuration and depends solely on this file to establish a database connection. If your starting a project from scratch, make sure to set up your JPA project before trying to use JPAstreamer.

Having obtained a `JPAStreamer` instance, you are ready to go. Here is an example that includes both the instantiation and the querying:

[source, java]
----
public static void main(String[] args) {

    JPAStreamer jpaStreamer = JPAStreamer.createJPAStreamerBuilder("sakila") #<1>
        .build();

    long count = jpaStreamer.stream(Film.class)
        .filter(Film$.title.startsWith("A"))
        .count();

    System.out.format("There are %d films with a title that starts with A", count);
}
----

== Resetting the Streamer 
Calling `jpaStreamer.stream(Class<T> entityClass)` creates a dedicated Streamer for the provided Entity class. The Streamer instance is reused for subsequent calls on `jpaStreamer.stream()` on the same Entity, see example below: 

[source, Java]
----
JPAStreamer jpaStreamer = JPAStreamer.createJPAStreamerBuilder("sakila") 
        .build();

long count = jpaStreamer.stream(Film.class) <1>
        .filter(Film$.title.startsWith("A"))
        .count();

long count2 = jpaStreamer.stream(Film.class) <2>
        .filter(Film$.title.startsWith("A"))
        .count();
----
<1> The first call to `jpaStreamer.stream(Film.class)` will create a `Streamer` of `Film` entities 
<2> The second call will reuse the previously configured `Streamer`

A `Streamer` instance hold a `javax.persistence.EntityManager` which has its own first-layer cache. Thus by default, database changes performed by another application, or made directly on the database, will not be detected. In the example above, the addition of the film "Avatar" to the database between the first and second count query therefore goes unnoticed and `count` will equal `count2`. 

To ensure that database updates performed by another application are detected, you must reset the Streamer between queries. This will effectively remove the existing Streamer for the specified Entity. The next query will create a new Streamer with a new `EntityManager`, resetting the first-level cache associated with the Entity.

You can reset the Streamer for one or more Entity classes with the following command: 

[source, Java]
----
jpaStreamer.resetStreamer(Class<?>... entityClasses); 
----

We can thus update the prior example to ensure that database changes are detected as follows: 

[source, Java]
----
JPAStreamer jpaStreamer = JPAStreamer.createJPAStreamerBuilder("sakila") 
        .build();

long count = jpaStreamer.stream(Film.class) <1>
        .filter(Film$.title.startsWith("A"))
        .count();

jpaStreamer.resetStreamer(Film.class); <2>

long count2 = jpaStreamer.stream(Film.class) <3>
        .filter(Film$.title.startsWith("A"))
        .count();
----
<1> Creates a Streamer of `Film` entities
<2> Resets (removes) the Streamer of `Film` entities. This resets the first-level cache. 
<3> Creates a new Streamer of `Film` entities

== What's Next 
The xref:sql-equivalents.adoc[next section] demonstrates how to use the available Stream operators and how they map to SQL constructs.

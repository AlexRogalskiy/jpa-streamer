= Terminal Operations
keywords: stream, jpastreamer, java, terminal operations
author: Per Minborg
:reftext: Terminal Operations
:navtitle: Terminal Operations
:source-highlighter: highlight.js

A terminal operation starts the `Stream` and returns a result that depends on the `Stream` pipeline and content.For example, `collect` is a terminal operation because additional operation cannot be added to a `Stream` pipeline after `collect` has been called.

NOTE: In the examples below, many of the lambdas could be replaced by method references (e.g. the lambda `() -> new StringBuilder` can be replaced by a method reference `StringBuilder::new`).

== Common Operations
The following terminal operations are accepted by a `Stream`:

[width="100%", cols="3", options="header"]
|==========================================================
| Operation         | Parameter(s)         | Action
| `forEach`         | `Consumer`           | Performs the given `Consumer` action for each element in the stream in any order
| `forEachOrdered`  | `Consumer`           | Performs the given `Consumer` action for each element in the stream in stream order
| `collect`         | `Collector`          | Returns a reduction of the elements in the stream. For example a `List`, `Set` or a `Map`
| `min`             | `Comparator`         | Returns the smallest element (as determined by the provided `Comparator`) in the stream (if any)
| `max`             | `Comparator`         | Returns the biggest element (as determined by the provided `Comparator`) in the stream (if any)
| `count`           | -                    | Returns the number of elements in the stream
| `anyMatch`        | `Predicate`          | Returns whether at least one element in this stream matches the provided `Predicate`
| `allMatch`        | `Predicate`          | Returns whether all elements in this stream match the provided `Predicate`
| `noneMatch`       | `Predicate`          | Returns whether no elements in this stream match the provided `Predicate`
| `findFirst`       | -                    | Returns the first element in this stream (if any)
| `findAny`         | -                    | Returns any element in this stream (if any)
| `toArray`         | -                    | Returns an array containing all the elements in this stream
| `toArray`         | `IntFunction`        | Returns an array containing all the elements in this stream whereby the array is created using the provided `IntFunction`
|==========================================================

=== forEach

[source,java]
----
     Stream.of("B", "A", "C" , "B")
        .forEach(System.out::print);
----
might output "CBBA". However, there is no guarantee of a particular order  using `forEach`. Despite this, most `Stream` implementations actually _would_ output "BACB".

=== forEachOrdered

[source,java]
----
     Stream.of("B", "A", "C" , "B")
        .forEachOrdered(System.out::print);
----
*always* outputs "BACB" (as opposed to `forEach`).

=== collect

[source,java]
----
     Stream.of("B", "A", "C" , "B")
        .collect(Collectors.toList());
----
returns a `List<String>` equal to ["B", "A", "C", "B"]

[source,java]
----
     Stream.of("B", "A", "C" , "B")
        .collect(Collectors.toSet());
----
returns a `Set<String>` equal to ["A", "B", "C"]

[source,java]
----
    Stream.of("I", "am", "a", "stream")
        .collect(Collectors.toMap(
            s -> s.toLowerCase(), // Key extractor
            s -> s.length())      // Value extractor
        )
----
returns a `Map<String, Integer>` equal to {a=1, stream=6, i=1, am=2}. Thus, the `Map` contains a mapping from a word (key) to how many characters that word has (value).

=== min
[source,java]
----
     Stream.of("B", "A", "C" , "B")
        .min(String::compareTo);
----
returns `Optional[A]` because "A" is the smallest element in the stream.

[source,java]
----
    Stream.<String>empty()
        .min(String::compareTo);
----
returns `Optional.empty` because there is no min value because the stream is empty.

=== max

[source,java]
----
     Stream.of("B", "A", "C" , "B")
        .max(String::compareTo);
----
returns `Optional[C]` because "C" is the largest element in the stream.

[source,java]
----
    Stream.<String>empty()
        .max(String::compareTo);
----
returns `Optional.empty` because there is no max value because the stream is empty.

=== count

[source,java]
----a
     Stream.of("B", "A", "C" , "B")
        .count();
----
returns 4 because there are four elements in the stream.

[source,java]
----a
    Stream.empty()
        .count();
----
returns 0 because there are no elements in an empty stream.

=== anyMatch
[source,java]
----
    Stream.of("B", "A", "C", "B")
        .anyMatch("A"::equals);
----
returns `true` because there is an "A" element in the stream.

[source,java]
----
    Stream.of("B", "A", "C", "B")
        .anyMatch("Z"::equals);
----
returns `false` because there are no "Z" elements in the stream.

=== noneMatch

[source,java]
----
    Stream.of("B", "A", "C", "B")
        .noneMatch("A"::equals);
----
returns `false` because there is an "A" element in the stream.

[source,java]
----
    Stream.of("B", "A", "C", "B")
        .noneMatch("Z"::equals);
----
returns `true` because there are no "Z" elements in the stream.

=== findFirst

[source,java]
----
    Stream.of("B", "A", "C", "B")
        .findFirst();
----
returns `Optional[B]` because "B" is the first element in the stream.

[source,java]
----
    Stream.<String>empty()
        .findFirst();
----
returns `Optional.empty` because the stream is empty.

=== findAny
[source,java]
----
    Stream.of("B", "A", "C", "B")
        .findAny();
----
might return `Optional[C]` or any other element in the stream.

[source,java]
----
    Stream.<String>empty()
        .findAny();
----
returns `Optional.empty` because the stream is empty.

=== toArray
[source,java]
----
    Stream.of("B", "A", "C", "B")
        .toArray();
----
Returns an array containing [B, A, C, B] created automatically by the `toArray` operator.

[source,java]
----
    Stream.of("B", "A", "C", "B")
        .toArray(String[]::new)
----
Returns an array containing [B, A, C, B] that will be created by the provided constructor, for example using the equivalent to `new String[4]`.

== Less Common Operations

Here is a list of other terminal operations that are a bit less commonly used by at least some programmers:

[width="100%", cols="3", options="header"]
|==========================================================
| Operation         | Parameter(s)         | Action
| `collect`         | `Supplier, BiConsumer, BiConsumer`   | Returns a reduction of the elements in the stream starting with an empty reduction (e.g. an empty `List`) obtained from the `Supplier` and then applying the first `BiConsumer` for each element and at the end, combining using the second `BiConsumer`
| `reduce`          | `T, BinaryOperation` | Using a first `T` and then subsequently applying a `BinaryOperation` for each element in the stream, returns the value of the last value (reduction)
| `reduce`          | `BinaryOperation`    | By subsequently applying a `BinaryOperation` for each element in the stream, returns the value of the last value (reduction)
| `reduce`          | `T, BiFunction, BinaryOperator`          | In parallel, using  first values `T` and then subsequently applying a `BiFunction` for each element in the stream, returns the value of the last values combined using the combining `BinaryOperator`
| `iterator`        | -                    | Returns an `Iterator` of all the values in this stream
| `spliterator`     | -                    | Returns a `Spliterator` with all the values in this stream
|==========================================================

=== collect with 3 Parameters

[source,java]
----
            Stream.of("B", "A", "C", "B")
                                .collect(
                    () -> new StringBuilder(),
                    (sb0, sb1) -> sb0.append(sb1),
                    (sb0, sb1) -> sb0.append(sb1)
                )
----
returns a `StringBuilder` containing "BACB" that will be created by the provided supplier and then built up by the append-lambdas.

=== reduce
[source,java]
----
    Stream.of(1, 2, 3, 4)
        .reduce((a, b) -> a + b)
----
returns the value of `Optional[10]` because 10 is the sum of all `Integer` elements in the `Stream`. If the `Stream` is empty, `Optional.empty()` is returned.

[source,java]
----
    Stream.of(1, 2, 3, 4)
        .reduce(100, (a, b) -> a + b)
----
returns the value of 110 since all the `Integer` elements in the `Stream` are added to the `Integer` 100. If the `Stream` is empty, 100 is returned.

[source,java]
----
    Stream.of(1, 2, 3, 4)
        .parallel()
        .reduce(
            0,
            (a, b) -> a + b,
            (a, b) -> a + b
        )
----
returns the value of 10 since this example simply adds all the `Integer` elements in the `Stream` beginning with 0. The `Stream` can be executed in parallel whereby the last lambda will be used to combine results from each thread. If the `Stream` is empty, 0 is returned.

=== iterator
[source,java]
----
    Iterator<String> iterator
        = Stream.of("B", "A", "C", "B")
            .iterator();
----
creates a new `Iterator` over all the elements in the `Stream`.

=== spliterator

[source,java]
----
    Spliterator<String> spliterator
        = Stream.of("B", "A", "C", "B")
            .spliterator();
----
creates a new `Spliterator` over all the elements in the `Stream`.

== Primitive Stream Operations
Primitive streams (like `IntStream` and `LongStream`) provide similar functionality as ordinary streams but usually the parameter count and types differ so that primitive streams can accept more optimized function variants.

Here is a list of terminal operations that are available *only* for primitive streams:

[width="100%", cols="3", options="header"]
|==========================================================
| Operation | Parameter(s) | Action
| `sum`             | - | Returns a reduction of the elements which is the sum of all elements in the stream
| `average`         | - | Returns a reduction of the elements which is the average of all elements in the stream (if any)
| `summaryStatistics`| - | Returns a reduction of the elements which is a summary of a number of statistic measurements (min, max, sum, average and count)
|==========================================================

=== sum

[source,java]
----
    IntStream.of(1, 2, 3, 4)
        .sum()
----
returns 10 because 10 is the sum of all elements in the `Stream`.

=== average

[source,java]
----
    IntStream.of(1, 2, 3, 4)
        .average()
----
returns `OptionalDouble[2.5]` because 2.5 is the average of all elements in the `Stream`. If the `Stream` is empty, `OptionalDouble.empty()` is returned.

=== summaryStatistics
[source,java]
----
    IntStream.of(1, 2, 3, 4)
        .summaryStatistics()
----
returns `IntSummaryStatistics{count=4, sum=10, min=1, average=2.500000, max=4}`.

If the stream is empty, `IntSummaryStatistics{count=0, sum=0, min=2147483647, average=0.000000, max=-2147483648}` is returned (max is initially set to `Integer.MIN_VALUE` which is -2147483648 and min is set to `Integer.MAX_VALUE` which is 2147483648).

## Examples

The examples below operates on entities of type `User`. Note that the only thing that needs to be provided is the `id` and all the other fields will be derived from the this field. This is good for tests and examples but of course not so useful in real applications.  The `User` class looks like this:

``` java
    static class User {

        private static final List<String> CARS = Arrays.asList("Toyota", "Volvo", "Tesla", "Fiat", "Ford");

        private final int id;

        public User(int id) {
            this.id = id;
        }

        public int getId() {
            return id;
        }

        public String getName() {
            return "Name" + id;
        }

        public String getPassword() {
            return "PW" + (id ^ 0x7F93A27F);
        }

        public String getFavoriteCar() {
            return CARS.get(id % CARS.size());
        }

        public int getBornYear() {
            return 1950 + id % 50;
        }

        @Override
        public String toString() {
            return String.format(
                "{id=%d, name=%s, password=%s, favoriteCar=%s, bornYear=%d}",
                getId(),
                getName(),
                getPassword(),
                getFavoriteCar(),
                getBornYear()
            );
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof User)) {
                return false;
            }
            User that = (User) obj;
            return this.id == that.id;
        }

        @Override
        public int hashCode() {
            return id;
        }

    }

```
As previously stated, users are really not real users but instead they are synthetically generated from the user id. Because the id defines all other fields, only the id field needs to be used in the `equals` and `hashCode` methods.

The first users will thus be:

| id  | User                                                                         |
| :-- | :--------------------------------------------------------------------------- |
| 0   | {id=0, name=Name0, password=PW346289151, favoriteCar=Toyota, bornYear=1950}  |
| 1   | {id=1, name=Name1, password=PW1420030975, favoriteCar=Volvo, bornYear=1951}  |
| 2   | {id=2, name=Name2, password=PW883160063, favoriteCar=Tesla, bornYear=1952}   |
| 3   | {id=3, name=Name3, password=PW1956901887, favoriteCar=Fiat, bornYear=1953}   |
| 4   | {id=4, name=Name4, password=PW77853695, favoriteCar=Ford, bornYear=1954}     |
| 5   | {id=5, name=Name5, password=PW1151595519, favoriteCar=Toyota, bornYear=1955} |
| ... | ...                                                                          |

There is also a `UserManager` that provides a static stream method that will return a `Stream<User>` that contains 1000 elements (with user ids in the range 0 to 999). The `UserManager` class is shown hereunder:
``` java
    static class UserManager {
        static Stream<User> stream() {
            return IntStream.range(0, 1000)
                .mapToObj(User::new);
        }
    }
```
Note how the stream method creates an `IntStream` with elements from 0 to 999 and then maps each `int` element to a `User` object using the `User` constructor that takes an `int` as an argument.


### Count the Number of Ford Likers
The example below counts the number of users that like Ford:
``` java
    long count = UserManager.stream()
        .filter(u -> "Ford".equals(u.getFavoriteCar()))
        .count();

        System.out.format("There are %d users that supports Ford %n", count);
```
The code above will produce:
``` text
There are 200 users that supports Ford
```

### Calculate Average Age
The following example calculates the average age of the users that like Tesla assuming the current year is 2017:
``` java
    OptionalDouble avg = UserManager.stream()
        .filter(u -> "Tesla".equals(u.getFavoriteCar()))
        .mapToInt(u -> 2017 - u.getBornYear()) // Calculates the age
        .average();

    if (avg.isPresent()) {
        System.out.format("The average age of Tesla likers are %d years %n", avg.getAsDouble());
    } else {
        System.out.format("There are no Tesla lovers");
    }
```
The code above will produce:
``` text
The average age of Tesla likers are 42.500000 years
```

### Find the Youngest Volvo Digger
The next example sets out to locate the youngest Volvo digger. The solution imposed below sorts all users in bornYear order and then picks the first one. Is there another solution without sort?
``` java
Comparator<User> comparator = Comparator.comparing(User::getBornYear).reversed();

    Optional<User> youngest = UserManager.stream()
        .filter(u -> "Volvo".equals(u.getFavoriteCar()))
        .sorted(comparator)
        .findFirst();

    youngest.ifPresent(u
        -> System.out.println("Found the youngest Volvo digger which is :" + u.toString())
    );
```
This will produce the following output:
``` text
Found the youngest Volvo digger which is :{id=46, name=Name46, password=PW782496767, favoriteCar=Volvo, bornYear=1996}
```

### Collect a Stream in a List
The following example collects all users that love Fiat in a List:
``` java
        List<User> fiatLovers = UserManager.stream()
            .filter(u -> "Fiat".equals(u.getFavoriteCar()))
            .collect(Collectors.toList());

        System.out.format("There are %d fiat lovers %n", fiatLovers.size());
```
The code above will produce:
``` text
There are 200 fiat lovers
```

### Element Flow
The example below examines the flow of elements and the different operations in the stream's pipeline. A `Stream` with five names is created and a `filter` is used to find those having a name that starts with the letter "A".
A `sort` operation is also applied to the remaining names and then lastly the names are mapped to lower case. Lastly the remaining elements are printed. Print statements are used in between operations to enable observation of the separate operation:
``` java
    Stream.of("Bert", "Alice", "Charlie", "Assian", "Adam")
        .filter(s -> {
            String required = "A";
            boolean result = s.startsWith(required);
            System.out.format("filter        : \"%s\".startsWith(\"%s\") is %s (%s) %n", s, required, result, result ? "retained" : "dropped");
            return result;
        })
        .sorted((s1, s2) -> {
            int result = s1.compareTo(s2);
            System.out.format("sort          : compare(%s, %s) is %d (%s)%n", s1, s2, result, result < 0 ? "not swapped" : "swapped");
            return result;
        })
        .map(s -> {
            String result = s.toLowerCase();
            System.out.format("map           : %s -> %s %n", s, result);
            return result;
        })
        .forEachOrdered(s
            -> System.out.println("forEachOrdered: " + s)
        );
```
This will print:
``` text
filter        : "Bert".startsWith("A") is false (dropped)
filter        : "Alice".startsWith("A") is true (retained)
filter        : "Charlie".startsWith("A") is false (dropped)
filter        : "Assian".startsWith("A") is true (retained)
filter        : "Adam".startsWith("A") is true (retained)
sort          : compare(Assian, Alice) is 7 (swapped)
sort          : compare(Adam, Assian) is -15 (not swapped)
sort          : compare(Adam, Assian) is -15 (not swapped)
sort          : compare(Adam, Alice) is -8 (not swapped)
map           : Adam -> adam
forEachOrdered: adam
map           : Alice -> alice
forEachOrdered: alice
map           : Assian -> assian
forEachOrdered: assian
```
So, in the end, the stream delivered the elements "adam", "alice" and "assian" as expected. Note how `sort` needs to retrieve all the element via the `filter` stage before it can emit result to the next stage. On the contrary, the last steps are executed in pipeline order because both `map` and `forEachOrdered` can process a stream element one at a time.